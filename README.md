# QuarkGluonJets </br>
This repository includes Jupyter notebook related to the tasks mentioned in the project: <https://ml4sci.org/gsoc/2023/proposal_FALCON2.html>.

1. Common Task 1. Auto-encoder of the quark/gluon events: The task has been implemented in VAE.ipynb. This notebook implements a Variational Autoencoder (VAE) model using Pytorch. We use 5 convolutional layers for encoding and 5 transposed convolutional layer for decoding. As input, we took the 3 channels and normalised it by deducting the mean and dividing it with the variance for each batch. The reconstructed image are shown at the end of the notebook where we can see how the normalised JET images turn out from the VAE model.

2. Common Task 2. Jets as graphs: The task has been implemented in GraphClassifier.ipynb. For dataprocessing and for model creation, we used Pytorch and Pytorch Geometric. During dataprocessing, we converted the non-zero pixels into nodes and created an adjacent pixel graph. Along with that, we stored the 3-dimensional position of the pixels with 3rd dimension as 0 for each pixel. We used GATv2Conv for attention based mesage passing, PointTransformerConv for position based message passing and ClusterGCNConv for cluster based message passing. At last, we used m0 and pt values for each images and learned the graph embedding for classification.

3. Special Task 1. Graph Representation Learning for Fast Detector Simulation: The task has been implemented in GVAE.ipynb. We used the dataprocessing part similar to GraphClassifier.ipynb. Here we take 4 layers for encoding and 4 layers for decoding. In each layer, there exists 2 messeage passing convolution layers - GATv2Conv and ClusterGCNConv. After passing though the convolutional layers, we create a S matrix for denoting the clusters in which each node should belong and downsampling the graph using deep_mincut_pool function. In decoder, we are using this S matrix for upsampling.
